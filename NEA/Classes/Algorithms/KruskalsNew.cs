using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace NEA.Classes.Algorithms
{
    public class KruskalsNew<T>
    {
        AdjacencyList<T> graph; //Graph is the inputted graph
        AdjacencyList<T> minSpanTree; //This is the outputted graph
        double MST;
        public KruskalsNew(AdjacencyList<T> inAdjList)
        {
            graph = inAdjList;
            minSpanTree = new AdjacencyList<T>();
        }

        private void PopulateNodesToVisit(ref List<T> nodesToVisit) //Works from testnig
        {
            foreach (var i in graph.adjList.Keys)
            {
                nodesToVisit.Add(i);
            }
        }
        private void PopulateMSTAdjList() //Adds each key to the adjList. Works from testing
        {
            foreach (var i in graph.adjList.Keys)
            {
                minSpanTree.AddNode(i);
            }
        }
        private double SumOfMSTGraph() //Finds the sum of all edges in the MST graph generated by the Kruskals algorithm
        {
            double sum = 0;
            foreach (var i in minSpanTree.adjList)
            {
                foreach (var j in i.Value)
                {
                    sum += j.Value;
                }
            }
            return sum;
        }
        public AdjacencyList<T> GetMSTAdjList()
        {
            return minSpanTree;
        }

        public double FindMST()
        {
            //This is giving me every edge????????


            graph.MakeUndirected();
            List<(T root, T destination, double edgeWeight)> listOfEdges = graph.ToEdgeList();
            List<(T root, T destination, double edgeWeight)> tempListOfEdges = listOfEdges;
            List<(T root, T destination, double edgeWeight)> finalListOfEdges = new List<(T root, T destination, double edgeWeight)>();
            List<T> nodesToVisit = new List<T>();
            PopulateNodesToVisit(ref nodesToVisit);
            PopulateMSTAdjList();
            bool isEdgeFoundValid = false;
            (T root, T destination, double edgeWeight) currentSmallestEdge;
            tempListOfEdges = graph.BubbleSortEdgeList(); //This is contributing to problem.

            T currentNode;

            foreach (var i in tempListOfEdges)
            {
                Console.WriteLine(i);
            }

            do //It's only doing this once?
            {
                Console.WriteLine("iterating:");
                foreach (var i in nodesToVisit)
                {
                    Console.WriteLine("nodesToVisit contains: " + i);
                }
                Console.WriteLine("|");

                tempListOfEdges = listOfEdges; //Each cycle I'll do this and then remove the invalid edges
                currentNode = nodesToVisit.First();
                nodesToVisit.Remove(currentNode); //Removing this so it doesn't interfere with removing invalid edges

                foreach (var i in nodesToVisit)
                {
                    Console.WriteLine("nodesToVisit contains: " + i);
                }
                Console.WriteLine("/");

                //Removing edges that aren't connected to nodes that've either been visited or the current node:

                //The removing logic seems to be the source of all of my problems
                foreach (var i in listOfEdges)
                {
                    //This needs to be more thorough
                    if (nodesToVisit.Contains(i.root) && nodesToVisit.Contains(i.destination))
                    {
                        //Removes only if both the source and destination node haven't been visited yet
                        tempListOfEdges.Remove(i); //Reference stored, not copying everything over, leading to a collection modified error!!!!!!!
                        Console.WriteLine("removing: " + i.root + "," + i.destination + "," + i.edgeWeight + " from tempListOfEdges");
                    }
                    Console.WriteLine("Lóóp");
                    //Does 3 loops then breaks?
                }

                //Never reaches beyond this point because an exception occurs, which is handled over in GUIWindow.cs
                //COLLECTION WAS MODIFIED 

                Console.WriteLine("!!!!");
                foreach (var i in finalListOfEdges)
                {
                    tempListOfEdges.Remove(i); //So it doesn't keep selecting previously-selected edges
                    Console.WriteLine("removing previously selected: " + i.root + "," + i.destination + "," + i.edgeWeight + " from tempListOfEdges");
                }

                Console.WriteLine("!!!!");
                currentSmallestEdge = tempListOfEdges[0];
                foreach (var i in tempListOfEdges)
                {
                    if (i.edgeWeight < currentSmallestEdge.edgeWeight)
                    {
                        currentSmallestEdge = i; //Gets the smallest valid edge
                    }
                }

                

                minSpanTree.AddEdge(currentSmallestEdge.root, currentSmallestEdge.destination, currentSmallestEdge.edgeWeight, true);
                if (!minSpanTree.AreCycles()) //No cycles present in testing so this works
                {
                    //No cycles, keep it in the MST
                    //Removes the nodes which will now certainly have been visited from nodesToVisit:
                    nodesToVisit.Remove(currentSmallestEdge.root);
                    Console.WriteLine("Removing from nodesToVisit: " + currentSmallestEdge.root);
                    nodesToVisit.Remove(currentSmallestEdge.destination);
                    Console.WriteLine("Removing from nodesToVisit: " + currentSmallestEdge.destination);
                    finalListOfEdges.Add(currentSmallestEdge);
                }
                else
                {
                    Console.WriteLine("Cycle detected");
                    minSpanTree.RemoveEdge(currentSmallestEdge.root, currentSmallestEdge.destination);
                }
                
                foreach (var i in finalListOfEdges)
                {
                    Console.WriteLine("in finalListOfEdges: " + i);
                }

                foreach (var i in nodesToVisit)
                {
                    Console.WriteLine("nodesToVisit contains: " + i);
                }
                Console.WriteLine(";"); //This one isn't happening?

            } while (nodesToVisit.Count > 0);






            //At the end I could make the graph undirected again for returning it??
            //Using the finalListOfEdges, I could stop adding to minSpanTree and just convert it all later

            MST = SumOfMSTGraph();
            return MST;
        }
        public double GetMST()
        {
            return MST;
        }
    }
}
