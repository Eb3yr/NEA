using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace NEA.Classes.Algorithms
{
    public class KruskalsLessOldStillRubbish<T>
    {
        AdjacencyList<T> graph; //Graph is the inputted graph
        AdjacencyList<T> minSpanTree; //This is the outputted graph
        double MST;
        public KruskalsLessOldStillRubbish(AdjacencyList<T> inAdjList)
        {
            graph = inAdjList;
            minSpanTree = new AdjacencyList<T>();
        }

        private void PopulateNodesToVisit(ref List<T> nodesToVisit) //Works from testnig
        {
            foreach (var i in graph.adjList.Keys)
            {
                nodesToVisit.Add(i);
            }
        }
        private void PopulateMSTAdjList() //Adds each key to the adjList. Works from testing
        {
            foreach (var i in graph.adjList.Keys)
            {
                minSpanTree.AddNode(i);
            }
        }
        private double SumOfMSTGraph() //Finds the sum of all edges in the MST graph generated by the Kruskals algorithm
        {
            double sum = 0;
            foreach (var i in minSpanTree.adjList)
            {
                foreach (var j in i.Value)
                {
                    sum += j.Value;
                }
            }
            return sum;
        }
        public AdjacencyList<T> GetMSTAdjList()
        {
            return minSpanTree;
        }

        public double FindMST()
        {
            //This is giving me every edge????????


            graph.MakeUndirected();
            List<(T root, T destination, double edgeWeight)> listOfEdges = graph.ToEdgeList();
            List<(T root, T destination, double edgeWeight)> tempListOfEdges = new List<(T root, T destination, double edgeWeight)>();
            foreach (var i in listOfEdges)
            {
                tempListOfEdges.Add(i);
            }

            List<(T root, T destination, double edgeWeight)> finalListOfEdges = new List<(T root, T destination, double edgeWeight)>();
            List<T> nodesToVisit = new List<T>();
            PopulateNodesToVisit(ref nodesToVisit);
            PopulateMSTAdjList();
            bool isEdgeFoundValid = false;
            (T root, T destination, double edgeWeight) currentSmallestEdge;
            tempListOfEdges = graph.BubbleSortEdgeList(); //This is contributing to problem.

            T currentNode;

            Console.WriteLine("foreach (var i in tempListOfEdges)");
            //foreach (var i in tempListOfEdges)
            //{
            //    Console.WriteLine(i);
            //}

            do //It's only doing this once?
            {
                Console.WriteLine("Do while start");
                Console.WriteLine("iterating:");
                foreach (var i in nodesToVisit)
                {
                    Console.WriteLine("nodesToVisit contains: " + i);
                }
                Console.WriteLine("|");

                Console.WriteLine("foreach (var i in tempListOfEdges)");
                tempListOfEdges = new List<(T root, T destination, double edgeWeight)>(); //Each cycle I'll do this and then remove the invalid edges
                foreach (var i in listOfEdges)
                {
                    tempListOfEdges.Add(i);
                }
                foreach (var i in tempListOfEdges)
                {
                    Console.WriteLine(i);
                }

                //Doing that will prevent it from just passing reference and dying on the foreach() bit because it modifies itself

                currentNode = nodesToVisit.First();
                Console.WriteLine("CurrentNode is: " + currentNode);
                nodesToVisit.Remove(currentNode); //Removing this so it doesn't interfere with removing invalid edges

                foreach (var i in nodesToVisit)
                {
                    Console.WriteLine("nodesToVisit contains: " + i);
                }
                Console.WriteLine("/");

                //Removing edges that aren't connected to nodes that've either been visited or the current node:

                //The removing logic seems to be the source of all of my problems
                Console.WriteLine("Before looping: listOfEdges contains: ");
                foreach (var i in listOfEdges)
                {
                    Console.WriteLine(i);
                }
                Console.WriteLine("Before looping: tempListOfEdges contains: ");
                foreach (var i in tempListOfEdges)
                {
                    Console.WriteLine(i);
                }
                foreach (var i in listOfEdges)
                {
                    Console.WriteLine("A: Lóóp");
                    //This needs to be more thorough
                    if (nodesToVisit.Contains(i.root) && nodesToVisit.Contains(i.destination))
                    {
                        //Removes only if both the source and destination node haven't been visited yet
                        Console.WriteLine("A: removing: " + i.root + "," + i.destination + "," + i.edgeWeight + " from tempListOfEdges");
                        tempListOfEdges.Remove(i); //Reference stored, not copying everything over, leading to a collection modified error!!!!!!!
                        Console.WriteLine("B: removing: " + i.root + "," + i.destination + "," + i.edgeWeight + " from tempListOfEdges");
                    }
                    Console.WriteLine("B: Lóóp");
                    //Does 3 loops then breaks?

                    //After removing one thing it loops back around but collection is modified so it up and dies
                }
                Console.WriteLine("End Lóóp");
                Console.WriteLine("After looping: listOfEdges contains: ");
                foreach (var i in listOfEdges)
                {
                    Console.WriteLine(i);
                }
                Console.WriteLine("After looping: tempListOfEdges contains: ");
                foreach (var i in tempListOfEdges)
                {
                    Console.WriteLine(i);
                }
                //Never reaches beyond this point because an exception occurs, which is handled over in GUIWindow.cs
                //COLLECTION WAS MODIFIED 

                Console.WriteLine("!!!!");
                foreach (var i in finalListOfEdges)
                {
                    tempListOfEdges.Remove(i); //So it doesn't keep selecting previously-selected edges
                    Console.WriteLine("A");
                    Console.WriteLine("removing previously selected: " + i.root + "," + i.destination + "," + i.edgeWeight + " from tempListOfEdges");
                    Console.WriteLine("B");
                }

                Console.WriteLine("!!!!");
                currentSmallestEdge = tempListOfEdges[0];
                Console.WriteLine("Current smallest edge is: " + currentSmallestEdge.root + ", " + currentSmallestEdge.destination + ": " + currentSmallestEdge.edgeWeight);
                foreach (var i in tempListOfEdges)
                {
                    if (i.edgeWeight < currentSmallestEdge.edgeWeight)
                    {
                        //Is this doing really annoying reference types maybe?
                        currentSmallestEdge = i; //Gets the smallest valid edge
                    }
                }

                

                minSpanTree.AddEdge(currentSmallestEdge.root, currentSmallestEdge.destination, currentSmallestEdge.edgeWeight, true);
                if (!minSpanTree.AreCycles()) //No cycles present in testing so this works
                {
                    //No cycles, keep it in the MST
                    //Removes the nodes which will now certainly have been visited from nodesToVisit:
                    nodesToVisit.Remove(currentSmallestEdge.root);
                    Console.WriteLine("Removing from nodesToVisit: " + currentSmallestEdge.root);
                    nodesToVisit.Remove(currentSmallestEdge.destination);
                    Console.WriteLine("Removing from nodesToVisit: " + currentSmallestEdge.destination);
                    finalListOfEdges.Add(currentSmallestEdge);
                }
                else
                {
                    Console.WriteLine("Cycle detected");
                    minSpanTree.RemoveEdge(currentSmallestEdge.root, currentSmallestEdge.destination);
                }

                Console.WriteLine("End of loop stats: \n");
                foreach (var i in finalListOfEdges)
                {
                    Console.WriteLine("in finalListOfEdges: " + i);
                }

                foreach (var i in nodesToVisit)
                {
                    Console.WriteLine("nodesToVisit contains: " + i);
                }
                Console.WriteLine(";\n\n\n");

            } while (nodesToVisit.Count > 0);



            /*
            new idea:
                -Do away with tempListOfEdges. Don't need it, just keep cycling through the adjList and pick the smallest VALID edge.
                 do this on a case-by-case basis for each edge each iteration, don't worry about efficiency losses because tempListOfEdges is already kinda inefficient if you think about it
                
                -This means I can do away with listOfEdges as well, and the (T, T, double) tuple I've been using and just go back to the AdjacencyList<T>.adjList thingymabob
            
             */

            /*
            
            That isn't actually the problem, there's just something stupid going on with picking which node to go with? Hoh?

            */




            //At the end I could make the graph undirected again for returning it??
            //Using the finalListOfEdges, I could stop adding to minSpanTree and just convert it all later

            MST = SumOfMSTGraph();
            return MST;
        }
        public double GetMST()
        {
            return MST;
        }
    }
}
