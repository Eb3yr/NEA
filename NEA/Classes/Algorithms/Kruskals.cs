using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Threading;

namespace NEA.Classes.Algorithms
{
    public class Kruskals<T>
    {
        AdjacencyList<T> graph; //Graph is the inputted graph
        AdjacencyList<T> minSpanTree; //This is the outputted graph
        double MST;
        public Kruskals(AdjacencyList<T> inAdjList)
        {
            graph = inAdjList;
            minSpanTree = new AdjacencyList<T>();
        }

        private void PopulateNodesToVisit(ref List<T> nodesToVisit) //Works from testnig
        {
            foreach (var i in graph.adjList.Keys)
            {
                nodesToVisit.Add(i);
            }
        }
        private void PopulateMSTAdjList() //Adds each key to the adjList. Works from testing
        {
            foreach (var i in graph.adjList.Keys)
            {
                minSpanTree.AddNode(i);
            }
        }
        private double SumOfMSTGraph() //Finds the sum of all edges in the MST graph generated by the Kruskals algorithm
        {
            double sum = 0;
            foreach (var i in minSpanTree.adjList)
            {
                foreach (var j in i.Value)
                {
                    sum += j.Value;
                }
            }
            return sum;
        }
        public AdjacencyList<T> GetMSTAdjList()
        {
            return minSpanTree;
        }

        public double FindMST()
        {
            //Leaving debug WriteLines in just commented out in case I find an issue later
            //Just gonna disable the Console from appearing later in NEA.csproj

            //Console.WriteLine("Start FindMST");
            graph.MakeUndirected();
            List<T> nodesToVisit = new List<T>();
            PopulateNodesToVisit(ref nodesToVisit);
            PopulateMSTAdjList();

            List<(T root, T destination, double edgeWeight)> currentListOfEdges = new List<(T root, T destination, double edgeWeight)>();
            (T root, T destination, double edgeWeight) currentSmallestEdge;
            List<(T root, T destination, double edgeWeight)> blacklistListOfEdges = new List<(T root, T destination, double edgeWeight)>(); //Used to block edges from being selected. Good for edges that've already been added to the MST, and for edges that cause cycles
            bool isDuplicate, swapOccurs; //Used later in selecting which edge to add to the MST

            nodesToVisit.RemoveAt(0); //Removes the first node to visit so that the algorithm can get started with the selection bit, otherwise it removes everything
            do 
            {
                //Thread.Sleep(1000);
                //Console.WriteLine("Do start");
                //If smallestEdge contains something from nodesToVisit, roll with it, else ignore, and repeat iteratively
                
                currentListOfEdges = graph.BubbleSortEdgeList(); //Returns a sorted list of edges

                //Removal logic here:

                foreach (var i in graph.ToEdgeList())
                {
                    //Console.WriteLine("a");
                    if (nodesToVisit.Contains(i.root) && nodesToVisit.Contains(i.destination))
                    {
                        //Removes only if both the source and destination node haven't been visited yet
                        currentListOfEdges.Remove(i);
                        //Console.WriteLine("Removing " + i);
                    }
                }
                //Console.WriteLine("a1");
                foreach (var i in blacklistListOfEdges)
                {
                    //Console.WriteLine("b");
                    currentListOfEdges.Remove(i); //So it doesn't keep selecting previously-selected edges
                }
                //Console.WriteLine("b1");
                //End of removal logic

                currentSmallestEdge = currentListOfEdges[0]; //Problem: currentListOfEdges is SHORT
                //Console.WriteLine("b2");
                foreach (var i in currentListOfEdges)
                {
                    //Console.WriteLine("c");
                    if (i.edgeWeight < currentSmallestEdge.edgeWeight)
                    {

                        currentSmallestEdge = i; //Gets the smallest valid edge
                    }
                    //Console.WriteLine("Current smallest edge is: " + currentSmallestEdge.root + ", " + currentSmallestEdge.destination + ": " + currentSmallestEdge.edgeWeight);
                }
                //Console.WriteLine("c1");

                minSpanTree.AddEdge(currentSmallestEdge.root, currentSmallestEdge.destination, currentSmallestEdge.edgeWeight, true);
                if (!minSpanTree.AreCycles()) //No cycles present in testing so this works
                {
                    //Console.WriteLine("d");
                    //No cycles, keep it in the MST
                    //Removes the nodes which will now certainly have been visited from nodesToVisit:
                    nodesToVisit.Remove(currentSmallestEdge.root);
                    nodesToVisit.Remove(currentSmallestEdge.destination);

                    blacklistListOfEdges.Add(currentSmallestEdge); //Used in finding which edges are valid to select smallest edges from as the algorithm progresses 
                }
                else
                {
                    //Console.WriteLine("d0");
                    //Cycle, remove the added edge as it should not be a part of the MST
                    //Console.WriteLine("Cycle detected");
                    minSpanTree.RemoveEdge(currentSmallestEdge.root, currentSmallestEdge.destination);
                    blacklistListOfEdges.Add(currentSmallestEdge); //Blacklists edge that generates a cycle
                }

               // Console.WriteLine("Do While ran once");
                
            } while (nodesToVisit.Count > 0);

            //Console.WriteLine("Oh hey you're out of the do while");


            //At the end I could make the graph undirected again for returning it??

            MST = SumOfMSTGraph();
            return MST;
        }
        public double GetMST()
        {
            return MST;
        }
    }
}
